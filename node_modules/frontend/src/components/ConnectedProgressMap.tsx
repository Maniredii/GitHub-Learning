import React, { useEffect, useState } from 'react';
import { ProgressMap } from './ProgressMap';
import { questApi } from '../services/questApi';
import { progressApi } from '../services/progressApi';
import type { Chapter } from '../../../shared/src/types';
import './ConnectedProgressMap.css';

export interface ConnectedProgressMapProps {
  onChapterClick?: (chapterId: string) => void;
}

export const ConnectedProgressMap: React.FC<ConnectedProgressMapProps> = ({
  onChapterClick,
}) => {
  const [chapters, setChapters] = useState<Chapter[]>([]);
  const [completedChapters, setCompletedChapters] = useState<string[]>([]);
  const [currentChapter, setCurrentChapter] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadProgressMapData();
  }, []);

  const loadProgressMapData = async () => {
    try {
      setLoading(true);
      setError(null);

      // Fetch chapters and user progress in parallel
      const [chaptersData, progressData] = await Promise.all([
        questApi.getAllChapters(),
        progressApi.getUserProgress(),
      ]);

      setChapters(chaptersData);
      setCurrentChapter(progressData.currentChapter);

      // Determine completed chapters based on quest completions
      const completedChapterIds = determineCompletedChapters(
        chaptersData,
        progressData.completedQuests
      );
      setCompletedChapters(completedChapterIds);
    } catch (err) {
      console.error('Failed to load progress map data:', err);
      setError(err instanceof Error ? err.message : 'Failed to load progress map');
    } finally {
      setLoading(false);
    }
  };

  const determineCompletedChapters = (
    allChapters: Chapter[],
    completedQuestIds: string[]
  ): string[] => {
    // A chapter is considered completed if all its quests are completed
    const completedChapterIds: string[] = [];

    for (const chapter of allChapters) {
      // Fetch quests for this chapter (we'll need to check if all are completed)
      // For now, we'll use a simpler heuristic: if the current chapter has moved past this one
      // or if we have completed quests from this chapter
      const hasCompletedQuestsInChapter = completedQuestIds.some((questId) =>
        questId.startsWith(chapter.id)
      );

      if (hasCompletedQuestsInChapter) {
        completedChapterIds.push(chapter.id);
      }
    }

    return completedChapterIds;
  };

  if (loading) {
    return (
      <div className="connected-progress-map connected-progress-map--loading">
        <div className="connected-progress-map__spinner">Loading your journey...</div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="connected-progress-map connected-progress-map--error">
        <div className="connected-progress-map__error">
          <p>{error}</p>
          <button onClick={loadProgressMapData} className="connected-progress-map__retry">
            Retry
          </button>
        </div>
      </div>
    );
  }

  return (
    <ProgressMap
      chapters={chapters}
      completedChapters={completedChapters}
      currentChapter={currentChapter}
      onChapterClick={onChapterClick}
    />
  );
};
