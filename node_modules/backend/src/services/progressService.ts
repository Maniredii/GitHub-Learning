import db from '../database/db';
import { UserProgress, UpdateUserProgressInput } from '../models/UserProgress';
import { Quest } from '../models/Quest';
import { v4 as uuidv4 } from 'uuid';

interface QuestCompletion {
  id: string;
  user_id: string;
  quest_id: string;
  completed_at: Date;
  xp_earned: number;
}

interface CompleteQuestResult {
  newXp: number;
  newLevel: number;
  leveledUp: boolean;
  unlockedQuests: string[];
  newRank?: string;
}

export class ProgressService {
  /**
   * XP thresholds for each level
   * Level 1: 0 XP
   * Level 2: 100 XP
   * Level 3: 250 XP
   * Level 4: 450 XP
   * Level 5: 700 XP
   * And so on with increasing requirements
   */
  private static readonly LEVEL_THRESHOLDS = [
    0, // Level 1
    100, // Level 2
    250, // Level 3
    450, // Level 4
    700, // Level 5
    1000, // Level 6
    1350, // Level 7
    1750, // Level 8
    2200, // Level 9
    2700, // Level 10
    3250, // Level 11
    3850, // Level 12
    4500, // Level 13
    5200, // Level 14
    5950, // Level 15
    6750, // Level 16
    7600, // Level 17
    8500, // Level 18
    9450, // Level 19
    10450, // Level 20
  ];

  /**
   * Rank names based on level
   */
  private static readonly RANKS = [
    { minLevel: 1, name: 'Apprentice Coder' },
    { minLevel: 3, name: 'Journeyman Archivist' },
    { minLevel: 6, name: 'Skilled Chrono-Coder' },
    { minLevel: 10, name: 'Master Time-Weaver' },
    { minLevel: 15, name: 'Legendary Git Guardian' },
    { minLevel: 20, name: 'Eternal Repository Keeper' },
  ];

  /**
   * Calculate level from XP
   */
  static calculateLevel(xp: number): number {
    let level = 1;
    for (let i = this.LEVEL_THRESHOLDS.length - 1; i >= 0; i--) {
      if (xp >= this.LEVEL_THRESHOLDS[i]) {
        level = i + 1;
        break;
      }
    }
    return level;
  }

  /**
   * Get rank name for a given level
   */
  static getRankForLevel(level: number): string {
    for (let i = this.RANKS.length - 1; i >= 0; i--) {
      if (level >= this.RANKS[i].minLevel) {
        return this.RANKS[i].name;
      }
    }
    return this.RANKS[0].name;
  }

  /**
   * Get XP required for next level
   */
  static getXpForNextLevel(currentLevel: number): number | null {
    if (currentLevel >= this.LEVEL_THRESHOLDS.length) {
      return null; // Max level reached
    }
    return this.LEVEL_THRESHOLDS[currentLevel];
  }

  /**
   * Check if a quest has been completed by a user
   */
  static async isQuestCompleted(userId: string, questId: string): Promise<boolean> {
    const completion = await db<QuestCompletion>('quest_completions')
      .where({ user_id: userId, quest_id: questId })
      .first();
    return !!completion;
  }

  /**
   * Get user's completed quest IDs
   */
  static async getCompletedQuestIds(userId: string): Promise<string[]> {
    const completions = await db<QuestCompletion>('quest_completions')
      .where({ user_id: userId })
      .select('quest_id');
    return completions.map((c) => c.quest_id);
  }

  /**
   * Get user progress
   */
  static async getUserProgress(userId: string): Promise<UserProgress | null> {
    const progress = await db<UserProgress>('user_progress')
      .where({ user_id: userId })
      .first();
    return progress || null;
  }

  /**
   * Update user progress
   */
  static async updateUserProgress(
    userId: string,
    updates: UpdateUserProgressInput
  ): Promise<UserProgress> {
    await db<UserProgress>('user_progress')
      .where({ user_id: userId })
      .update({
        ...updates,
        updated_at: new Date(),
      });

    const updated = await this.getUserProgress(userId);
    if (!updated) {
      throw new Error('Failed to update user progress');
    }
    return updated;
  }

  /**
   * Complete a quest and award XP
   */
  static async completeQuest(
    userId: string,
    questId: string,
    quest: Quest
  ): Promise<CompleteQuestResult> {
    // Check if quest already completed
    const alreadyCompleted = await this.isQuestCompleted(userId, questId);
    if (alreadyCompleted) {
      throw new Error('Quest already completed');
    }

    // Get current progress
    const progress = await this.getUserProgress(userId);
    if (!progress) {
      throw new Error('User progress not found');
    }

    const currentXp = progress.xp;
    const currentLevel = progress.level;

    // Calculate new XP and level
    const xpEarned = quest.xp_reward;
    const newXp = currentXp + xpEarned;
    const newLevel = this.calculateLevel(newXp);
    const leveledUp = newLevel > currentLevel;

    // Record quest completion
    await db<QuestCompletion>('quest_completions').insert({
      id: uuidv4(),
      user_id: userId,
      quest_id: questId,
      completed_at: new Date(),
      xp_earned: xpEarned,
    });

    // Update user progress
    const updates: UpdateUserProgressInput = {
      xp: newXp,
      level: newLevel,
      current_quest: questId,
    };

    // Update current chapter if this quest belongs to a different chapter
    if (quest.chapter_id !== progress.current_chapter) {
      updates.current_chapter = quest.chapter_id;
    }

    await this.updateUserProgress(userId, updates);

    // Get newly unlocked quests (quests in the same chapter that come after this one)
    const unlockedQuests = await this.getUnlockedQuests(userId, quest.chapter_id);

    const result: CompleteQuestResult = {
      newXp,
      newLevel,
      leveledUp,
      unlockedQuests,
    };

    if (leveledUp) {
      result.newRank = this.getRankForLevel(newLevel);
    }

    return result;
  }

  /**
   * Get unlocked quests for a user in a specific chapter
   */
  private static async getUnlockedQuests(
    userId: string,
    chapterId: string
  ): Promise<string[]> {
    // Get all quests in the chapter
    const allQuests = await db<Quest>('quests')
      .where({ chapter_id: chapterId })
      .orderBy('order', 'asc');

    // Get completed quest IDs
    const completedIds = await this.getCompletedQuestIds(userId);

    // Find the first uncompleted quest (sequential unlock)
    const unlockedQuests: string[] = [];
    for (const quest of allQuests) {
      if (!completedIds.includes(quest.id)) {
        unlockedQuests.push(quest.id);
        break; // Only unlock the next quest in sequence
      }
    }

    return unlockedQuests;
  }

  /**
   * Get progress statistics for a user
   */
  static async getProgressStats(userId: string): Promise<{
    xp: number;
    level: number;
    rank: string;
    currentChapter: string | null;
    currentQuest: string | null;
    completedQuests: string[];
    xpToNextLevel: number | null;
    totalQuestsCompleted: number;
  }> {
    const progress = await this.getUserProgress(userId);
    if (!progress) {
      throw new Error('User progress not found');
    }

    const completedQuests = await this.getCompletedQuestIds(userId);
    const rank = this.getRankForLevel(progress.level);
    const xpToNextLevel = this.getXpForNextLevel(progress.level);

    return {
      xp: progress.xp,
      level: progress.level,
      rank,
      currentChapter: progress.current_chapter,
      currentQuest: progress.current_quest,
      completedQuests,
      xpToNextLevel,
      totalQuestsCompleted: completedQuests.length,
    };
  }
}

export default ProgressService;
